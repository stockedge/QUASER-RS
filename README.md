# QUASAR-RS

**A Fast, Reliable, and Secure Programming Language for LLM Agents with Code Actions**

QUASARã¯ã€LLMã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ã‚³ãƒ¼ãƒ‰ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã«ç‰¹åŒ–ã—ãŸãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã®å®Ÿè£…ã§ã™ã€‚è«–æ–‡ã€ŒA Fast, Reliable, and Secure Programming Language for LLM Agents with Code Actionsã€ã«åŸºã¥ãã€Rustã§å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚

## ğŸŒŸ æ¦‚è¦

QUASARã¯ä»¥ä¸‹ã®ç‰¹å¾´ã‚’æŒã¤ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªã§ã™ï¼š

- **é«˜é€Ÿæ€§**: ä¸¦åˆ—å®Ÿè¡Œå¯èƒ½ãªå¤–éƒ¨å‘¼ã³å‡ºã—ã®è‡ªå‹•æ¤œå‡º
- **ä¿¡é ¼æ€§**: é–¢æ•°å‹ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã«ã‚ˆã‚‹æ˜ç¢ºãªå®Ÿè¡Œãƒ¢ãƒ‡ãƒ«
- **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**: å¤–éƒ¨é–¢æ•°å‘¼ã³å‡ºã—ã«ãƒ¦ãƒ¼ã‚¶ãƒ¼æ‰¿èªãŒå¿…è¦
- **ä¸ç¢ºå®Ÿæ€§ã®æ‰±ã„**: ã‚³ãƒ³ãƒ•ã‚©ãƒ¼ãƒãƒ«ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã«ã‚ˆã‚‹å€¤ã®é›†åˆã®è¡¨ç¾

## ğŸ“‹ è¨€èªä»•æ§˜

### åŸºæœ¬æ§‹æ–‡

QUASARãƒ—ãƒ­ã‚°ãƒ©ãƒ ã¯ä»¥ä¸‹ã®å½¢å¼ã§æ§‹æˆã•ã‚Œã¾ã™ï¼š

```
P ::= stmtâ‚; ...; stmtâ‚™; return x
```

### ãƒ‡ãƒ¼ã‚¿å‹

```rust
// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å€¤
Boolean(true/false)
Integer(i64)
Float(f64)
String("text")
Null

// è¤‡åˆå‹
List([value1, value2, ...])
Tuple((value1, value2, ...))

// ã‚³ãƒ³ãƒ•ã‚©ãƒ¼ãƒãƒ«å€¤ï¼ˆå€¤ã®é›†åˆï¼‰
ConformValue { possibilities: {value1, value2, ...} }
```

### æ–‡ï¼ˆStatementï¼‰

ã™ã¹ã¦ã®æ–‡ã¯ `å¤‰æ•° = æ“ä½œ` ã®å½¢å¼ï¼š

```rust
stmt ::= x = op

op ::=
    | prim c              // ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–å€¤
    | x                   // å¤‰æ•°å‚ç…§
    | (xâ‚, ..., xâ‚™)       // ã‚¿ãƒ—ãƒ«æ§‹ç¯‰
    | f x                 // å¤–éƒ¨é–¢æ•°å‘¼ã³å‡ºã—
    | proj i x            // ã‚¿ãƒ—ãƒ«ã®å°„å½±
    | fold w x block      // ãƒªã‚¹ãƒˆã®ç•³ã¿è¾¼ã¿
    | if x blockâ‚ blockâ‚‚  // æ¡ä»¶åˆ†å²
    | ?S                  // å¤–éƒ¨å‘¼ã³å‡ºã—ãƒ—ãƒ¬ãƒ¼ã‚¹ãƒ›ãƒ«ãƒ€ãƒ¼
    | join {xâ‚, ..., xâ‚™}  // å€¤ã®é›†åˆã®çµåˆ
```

### ãƒ–ãƒ­ãƒƒã‚¯ï¼ˆBlockï¼‰

```rust
block ::= {x â‡’ P}
```

ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å—ã‘å–ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãƒ–ãƒ­ãƒƒã‚¯ã€‚ä¸»ã«`fold`ã‚„`if`ã§ä½¿ç”¨ã€‚

### å¤–éƒ¨é–¢æ•°

QUASARã§ã¯å¤–éƒ¨é–¢æ•°å‘¼ã³å‡ºã—ãŒç‰¹åˆ¥ã«æ‰±ã‚ã‚Œã¾ã™ï¼š

```rust
// ä½¿ç”¨å¯èƒ½ãªå¤–éƒ¨é–¢æ•°
find(object) -> [patch1, patch2, ...]    // ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ¤œç´¢
simple_query(object) -> "yes"/"no"       // ç°¡å˜ãªã‚¯ã‚¨ãƒª
exists(object) -> true/false             // å­˜åœ¨ç¢ºèª
```

## ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

### ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«æ§‹æˆ

```
src/
â”œâ”€â”€ ast/                 # æŠ½è±¡æ§‹æ–‡æœ¨ã®å®šç¾©
â”‚   â”œâ”€â”€ value.rs        # å€¤ã¨ã‚³ãƒ³ãƒ•ã‚©ãƒ¼ãƒãƒ«å€¤
â”‚   â”œâ”€â”€ expression.rs   # å¼ã®å®šç¾©
â”‚   â”œâ”€â”€ statement.rs    # æ–‡ã®å®šç¾©
â”‚   â””â”€â”€ program.rs      # ãƒ—ãƒ­ã‚°ãƒ©ãƒ å…¨ä½“
â”œâ”€â”€ runtime/            # å®Ÿè¡Œæ™‚ã‚·ã‚¹ãƒ†ãƒ 
â”‚   â”œâ”€â”€ error.rs        # ã‚¨ãƒ©ãƒ¼å‹å®šç¾©
â”‚   â”œâ”€â”€ state.rs        # å®Ÿè¡ŒçŠ¶æ…‹ç®¡ç†
â”‚   â””â”€â”€ external.rs     # å¤–éƒ¨é–¢æ•°å®Ÿè£…
â”œâ”€â”€ interpreter/        # ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼
â”‚   â”œâ”€â”€ rewriter.rs     # æ›¸ãæ›ãˆãƒ«ãƒ¼ãƒ«
â”‚   â”œâ”€â”€ dispatcher.rs   # å¤–éƒ¨å‘¼ã³å‡ºã—ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒ
â”‚   â”œâ”€â”€ evaluator.rs    # å¼è©•ä¾¡
â”‚   â””â”€â”€ executor.rs     # ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œãƒ«ãƒ¼ãƒ—
â””â”€â”€ main.rs            # ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ
```

### å®Ÿè¡Œãƒ¢ãƒ‡ãƒ«

QUASARã®å®Ÿè¡Œã¯ä»¥ä¸‹ã®ã‚µã‚¤ã‚¯ãƒ«ã§è¡Œã‚ã‚Œã¾ã™ï¼š

1. **ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒãƒ•ã‚§ãƒ¼ã‚º**: å®Ÿè¡Œå¯èƒ½ãªå¤–éƒ¨å‘¼ã³å‡ºã—ã‚’æ¤œå‡º
2. **æ‰¿èªãƒ•ã‚§ãƒ¼ã‚º**: ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«å¤–éƒ¨å‘¼ã³å‡ºã—ã®å®Ÿè¡Œè¨±å¯ã‚’æ±‚ã‚ã‚‹
3. **éåŒæœŸå®Ÿè¡Œ**: æ‰¿èªã•ã‚ŒãŸå¤–éƒ¨å‘¼ã³å‡ºã—ã‚’ä¸¦åˆ—å®Ÿè¡Œ
4. **å†…éƒ¨æ›¸ãæ›ãˆ**: ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®å†…éƒ¨ãƒ«ãƒ¼ãƒ«ã‚’é©ç”¨
   - å¤‰æ•°ã®åˆ¥åè§£æ±º (`alias`)
   - ã‚¿ãƒ—ãƒ«ã®å°„å½± (`proj`)
   - æ¡ä»¶åˆ†å²ã®è§£æ±º (`if-t`, `if-f`)
   - ãƒ«ãƒ¼ãƒ—ã®å±•é–‹ (`fold`)
   - å®Œäº†ã—ãŸå¤–éƒ¨å‘¼ã³å‡ºã—ã®çµæœä»£å…¥ (`ext`)

### ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹

#### å†…éƒ¨ãƒ«ãƒ¼ãƒ«ï¼ˆR_intï¼‰

| ãƒ«ãƒ¼ãƒ« | èª¬æ˜ | å¤‰æ›ä¾‹ |
|--------|------|--------|
| **alias** | å¤‰æ•°ã®ã‚¨ã‚¤ãƒªã‚¢ã‚¹è§£æ±º | `y = x` â†’ `y`ã‚’`x`ã«ç½®æ› |
| **proj** | ã‚¿ãƒ—ãƒ«ã®å°„å½± | `y = proj 0 (a, b)` â†’ `y = a` |
| **if-t/if-f** | æ¡ä»¶åˆ†å²ã®å˜ç´”åŒ– | `if true then A else B` â†’ `A` |
| **fold** | ãƒ«ãƒ¼ãƒ—ã®å±•é–‹ | `fold [1,2] acc {...}` â†’ å±•é–‹ã•ã‚ŒãŸã‚¹ãƒ†ãƒƒãƒ— |

#### å¤–éƒ¨ãƒ«ãƒ¼ãƒ«ï¼ˆR_extï¼‰

| ãƒ«ãƒ¼ãƒ« | èª¬æ˜ |
|--------|------|
| **disp** | å¤–éƒ¨é–¢æ•°å‘¼ã³å‡ºã—ã®ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒ |
| **ext** | å®Œäº†ã—ãŸå¤–éƒ¨å‘¼ã³å‡ºã—ã®çµæœä»£å…¥ |

## ğŸš€ ä½¿ç”¨æ–¹æ³•

### ä¾å­˜é–¢ä¿‚

```toml
[dependencies]
tokio = { version = "1", features = ["full"] }
async-trait = "0.1"
thiserror = "1.0"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
ordered-float = { version = "4.0", features = ["serde"] }
futures = "0.3"
```

### å®Ÿè¡Œ

```bash
# ãƒ“ãƒ«ãƒ‰
cargo build

# å®Ÿè¡Œï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æ‰¿èªã‚ã‚Šï¼‰
cargo run

# å®Ÿè¡Œï¼ˆè‡ªå‹•æ‰¿èª - æœªå®Ÿè£…ï¼‰
# cargo run -- --auto-approve
```

### ã‚µãƒ³ãƒ—ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒ 

```rust
// ç”»åƒã‹ã‚‰ãƒ‰ãƒªãƒ³ã‚¯ã‚’æ¤œç´¢ã—ã€å­˜åœ¨ã™ã‚‹ã‚‚ã®ã®ã¿ã‚’åé›†
let statements = vec![
    // image_patch = "image_patch_object"
    Statement {
        variable: "image_patch".to_string(),
        expression: Expression::Primitive(Value::Primitive(
            PrimitiveValue::String("image_patch_object".to_string())
        )),
    },
    
    // drinks = find(image_patch)
    Statement {
        variable: "drinks".to_string(),
        expression: Expression::ExternalCall {
            function: "find".to_string(),
            argument: "image_patch".to_string(),
        },
    },
    
    // final_patches = fold drinks [] {...}
    Statement {
        variable: "final_patches".to_string(),
        expression: Expression::Fold {
            list: "drinks".to_string(),
            initial: "drink_patches".to_string(),
            block: Block { /* ... */ },
        },
    },
];
```

## âš ï¸ ç¾åœ¨ã®çŠ¶æ…‹ã¨åˆ¶é™äº‹é …

### å®Ÿè£…æ¸ˆã¿æ©Ÿèƒ½

âœ… åŸºæœ¬çš„ãªASTæ§‹é€   
âœ… å†…éƒ¨æ›¸ãæ›ãˆãƒ«ãƒ¼ãƒ«  
âœ… å¤–éƒ¨é–¢æ•°å‘¼ã³å‡ºã—ã®ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒ  
âœ… éåŒæœŸå®Ÿè¡Œç®¡ç†  
âœ… ãƒ¦ãƒ¼ã‚¶ãƒ¼æ‰¿èªã‚·ã‚¹ãƒ†ãƒ   
âœ… ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°  

### æ—¢çŸ¥ã®å•é¡Œ

âš ï¸ **ç„¡é™ãƒ«ãƒ¼ãƒ—**: ç¾åœ¨ã®ã‚µãƒ³ãƒ—ãƒ«ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒãƒ«ãƒ¼ãƒ—ãŒç™ºç”Ÿ  
âš ï¸ **å…¥åŠ›å‡¦ç†**: éåŒæœŸå…¥åŠ›å‡¦ç†ã«å•é¡ŒãŒã‚ã‚‹å¯èƒ½æ€§  
âš ï¸ **çµ‚äº†æ¡ä»¶**: ãƒ—ãƒ­ã‚°ãƒ©ãƒ çµ‚äº†ã®åˆ¤å®šãƒ­ã‚¸ãƒƒã‚¯ã«æ”¹å–„ãŒå¿…è¦  

### æœªå®Ÿè£…æ©Ÿèƒ½

ğŸ”„ å®Œå…¨ãªã‚³ãƒ³ãƒ•ã‚©ãƒ¼ãƒãƒ«ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹  
ğŸ”„ LSPã‚µãƒ¼ãƒãƒ¼  
ğŸ”„ æ§‹æ–‡è§£æå™¨ï¼ˆç¾åœ¨ã¯æ‰‹å‹•ã§ASTã‚’æ§‹ç¯‰ï¼‰  
ğŸ”„ è‡ªå‹•æ‰¿èªãƒ¢ãƒ¼ãƒ‰  
ğŸ”„ ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½  

## ğŸ”® ä»Šå¾Œã®æ‹¡å¼µäºˆå®š

### ãƒ•ã‚§ãƒ¼ã‚º1: åŸºæœ¬æ©Ÿèƒ½ã®å®‰å®šåŒ–
- [ ] ç„¡é™ãƒ«ãƒ¼ãƒ—å•é¡Œã®ä¿®æ­£
- [ ] å…¥åŠ›å‡¦ç†ã®æ”¹å–„
- [ ] ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆã®è¿½åŠ 
- [ ] ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ”¹å–„

### ãƒ•ã‚§ãƒ¼ã‚º2: ã‚³ãƒ³ãƒ•ã‚©ãƒ¼ãƒãƒ«ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹
- [ ] å€¤ã®é›†åˆã®å®Œå…¨ã‚µãƒãƒ¼ãƒˆ
- [ ] ä¸ç¢ºå®Ÿæ€§ã®ä¼æ’­
- [ ] æ¡ä»¶åˆ†å²ã§ã®é›†åˆå€¤å‡¦ç†
- [ ] ãƒ«ãƒ¼ãƒ—ã§ã®é›†åˆå€¤å‡¦ç†

### ãƒ•ã‚§ãƒ¼ã‚º3: é–‹ç™ºè€…ä½“é¨“ã®å‘ä¸Š
- [ ] æ§‹æ–‡è§£æå™¨ã®å®Ÿè£…
- [ ] LSPã‚µãƒ¼ãƒãƒ¼ã®å®Ÿè£…
- [ ] VS Codeæ‹¡å¼µ
- [ ] ãƒ‡ãƒãƒƒã‚¬ãƒ¼ã®å®Ÿè£…

### ãƒ•ã‚§ãƒ¼ã‚º4: é«˜åº¦ãªæ©Ÿèƒ½
- [ ] ä¸¦åˆ—åŒ–ã®æœ€é©åŒ–
- [ ] ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒãƒªã‚·ãƒ¼ã‚¨ãƒ³ã‚¸ãƒ³
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
- [ ] åˆ†æ•£å®Ÿè¡Œ

## ğŸ“š æŠ€è¡“è©³ç´°

### ã‚³ãƒ³ãƒ•ã‚©ãƒ¼ãƒãƒ«ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹

QUASARã®ç‰¹å¾´çš„ãªæ©Ÿèƒ½ã¨ã—ã¦ã€å€¤ãŒã€Œé›†åˆã€ã§ã‚ã‚‹å¯èƒ½æ€§ã‚’è¡¨ç¾ã§ãã¾ã™ï¼š

```rust
// ç¢ºå®Ÿãªå€¤
ConformValue::certain(Value::Primitive(PrimitiveValue::Boolean(true)))

// ä¸ç¢ºå®Ÿãªå€¤ï¼ˆé›†åˆï¼‰
ConformValue::uncertain(vec![
    Value::Primitive(PrimitiveValue::Boolean(true)),
    Value::Primitive(PrimitiveValue::Boolean(false)),
])
```

### æ›¸ãæ›ãˆãƒ«ãƒ¼ãƒ«ã®å®Ÿè£…

æ›¸ãæ›ãˆãƒ«ãƒ¼ãƒ«ã¯ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°ã‚’ä½¿ç”¨ã—ã¦å®Ÿè£…ï¼š

```rust
match &stmt.expression {
    Expression::Variable(src_var) => {
        // alias ãƒ«ãƒ¼ãƒ«
        if let Some(value) = state.lookup_var(src_var) {
            state.set_var(stmt.variable.clone(), value.clone());
            changed = true;
        }
    }
    Expression::If { condition, then_block, else_block } => {
        // if-t/if-f ãƒ«ãƒ¼ãƒ«
        let cond_value = state.lookup_var(condition);
        // æ¡ä»¶ã«å¿œã˜ã¦åˆ†å²ã‚’å‡¦ç†
    }
    // ...
}
```

### éåŒæœŸå®Ÿè¡Œç®¡ç†

å¤–éƒ¨é–¢æ•°å‘¼ã³å‡ºã—ã¯`tokio::spawn`ã§éåŒæœŸå®Ÿè¡Œï¼š

```rust
let handle = task::spawn(async move {
    if let Some(func) = get_external_function(&function_name) {
        func.call(&argument).await
    } else {
        Err(QuasarError::ExternalFunctionError(format!("Unknown function: {}", function_name)))
    }
});

state.pending_calls.push(PendingCall {
    id: call_id.clone(),
    assignment_var: call.assignment_var.clone(),
    handle,
});
```

## ğŸ¤ è²¢çŒ®

ã“ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã¯è«–æ–‡ã®æ¦‚å¿µå®Ÿè£…ã¨ã—ã¦ä½œæˆã•ã‚Œã¦ã„ã¾ã™ã€‚æ”¹å–„ææ¡ˆã‚„ãƒã‚°å ±å‘Šã‚’ãŠå¾…ã¡ã—ã¦ã„ã¾ã™ã€‚

## ğŸ“„ ãƒ©ã‚¤ã‚»ãƒ³ã‚¹

MIT License

## ğŸ“– å‚è€ƒæ–‡çŒ®

- è«–æ–‡: "A Fast, Reliable, and Secure Programming Language for LLM Agents with Code Actions"
- Rustå…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ: https://doc.rust-lang.org/
- TokioéåŒæœŸãƒ©ãƒ³ã‚¿ã‚¤ãƒ : https://tokio.rs/